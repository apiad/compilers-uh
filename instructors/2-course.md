# Estructura del curso

El curso presentado a continuación ha sido dividido en 16 _temas_ que coinciden
aproximadamente con las 16 conferencias y clases prácticas de un semestre.
Sin embargo, este curso puede ser adaptado a 2 semestres fácilmente, simplemente
duplicando la cantidad de tiempo que se dedica a cada tema, pues como se verá,
cada tema tiene una profundidad suficiente para ser cubierto en 2 o incluso 3
clases. Por otro lado, el curso también puede ser fácilmente reducido, ya sea eliminando
algunos de los temas, o compactando 2 temas en uno.

Para asistir a los instructores en la preparación de su curso particular, hemos
señalado en cada tema qué contenidos son necesarios, y cuáles son opcionales.
Así mismo, hemos indicado qué temas son prerequisitos de otros temas, de modo
que sea posible eliminar algunos o modificar el orden del curso a sabiendas de
que la consistencia de todo el programa no será afectada. Incluímos en cada tema
referencias al contenido relevante en la monografía que acompaña este manual.

Este curso de Compilación se apoya fuertemente en las clases prácticas para
lograr un dominio práctico de las materias impartidas. Por este motivo las
clases prácticas no son simplemente colecciones de ejercicios relacionados con
las conferencias. Por el contrario, a menudo en las clases prácticas se introducen
problemáticas que requieren de los estudiantes un pensamiento lateral.

\newpage

## Temas

### Introducción

**Conferencia**: Capítulo 1, *excepto* la sección sobre el lenguaje COOL.

> Entender la arquitectura básica de un compilador y familizarse con los
contenidos centrales del resto del curso.

- Presentar la estructura básica de un compilador
- Presentar los objetivos del curso
- Presentar la estructura del curso y el sistema de evaluación

**Estudio**: Capítulo 1, sección sobre el lenguaje COOL.

> Aprender los fundamentos básicos de COOL y familiarizarse con la sintaxis.

- Implementar `HelloWorld.cl`
- Implementar `Fibonacci.cl`
- Implementar `Hanoi.cl`

**Práctica**: Notebook 1

> Implementar un evaluador de expresiones simple, basado en un lexer hecho a mano
y un parser recursivo que ejecuta en tiempo $O(n \log n)$

- Implementar un lexer simple de números, paréntesis y operadores
- Implementar un evaluador de expresiones recursivo

### Análisis léxicográfico

### Parsing recursivo descendente

### Árbol de sintaxis abstracta

### Intépretes de árbol

### Expresiones regulares

### Parsing predictivo

### Parsing ascendente

### Gramáticas atributadas

### Análisis semántico - Verificación
